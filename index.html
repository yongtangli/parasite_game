<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="Parasite Game">
    <meta name="keywords" content="parasites">
    <link rel="icon" href="icon.png" type="image/png">
    <script type="text/JavaScript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
    <title>寄蟲跑台</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        .doc-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .doc-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-bg);
            color: var(--text-primary);
            padding: 30px;
            overflow-y: auto;
            box-shadow: none;
            border: none;
            border-radius: 0;
            z-index: 2001;
        }

        body.dark-mode .doc-page {
            background-color: var(--modal-bg);
            color: var(--text-primary);
        }

        #docContent {
          counter-reset: docEntryCounter;
          padding-left: 25px;
        }

        .doc-entry {
            margin: 0 auto 25px auto;
            padding: 0;
            padding-bottom: 20px;
            max-width: 650px;
            border-bottom: 1px solid var(--border-primary);
            position: relative;
        }

        .doc-entry::before {
          counter-increment: docEntryCounter;
          content: counter(docEntryCounter) ".";
          position: absolute;
          left: -25px;
          top: 0;
          width: 20px;
          text-align: right;
          color: var(--text-primary);
        }

        .doc-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .doc-entry img {
            display: block;
            max-width: 150px;
            height: auto;
            border-radius: 6px;
            margin-bottom: 12px;
            border: 1px solid var(--border-primary);
            box-shadow: 0 2px 5px var(--shadow-color);
            background-color: var(--bg-secondary);
        }

        .doc-text {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 100%;
        }

        .doc-text p {
            font-size: 1rem;
            line-height: 1.7;
            color: var(--text-primary);
            margin-bottom: 0;
        }

        .doc-text p strong {
            font-weight: 600;
        }

        .doc-text pre {
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--text-secondary);
            margin-top: 0;
            white-space: pre-wrap;
            word-break: break-word;
            font-family: inherit;
            background: none;
            padding: 0;
            border: none;
            border-radius: 0;
        }

        @font-face {
            font-family: 'Germgoth';
            src: url('fonts/Germgoth.woff') format('woff');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            --bg-primary: #F9F7F3;
            --bg-secondary: #FFFFFF;
            --text-primary: #404040;
            --text-secondary: #666;
            --text-muted: #999;
            --heading-color: #383838;
            --border-primary: #EAEAEA;
            --border-secondary: #D8D8D8;
            --accent-blue: #6D8A96;
            --accent-blue-hover: #5A7580;
            --accent-green: #79A88F;
            --accent-orange: #D98C60;
            --accent-red: #C76D6D;
            --shadow-color: rgba(0, 0, 0, 0.07);
            --focus-ring: rgba(109, 138, 150, 0.15);
            --modal-bg: #FDFBF8;
            --card-answer-bg: rgba(249, 247, 243, 0.85);
            --toggle-icon-color: #2C3E50;
            --toggle-moon-mask: #F9F7F3;

            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.4s ease, color 0.4s ease;
        }

        body.dark-mode {
            --bg-primary: #1e1e1e;
            --bg-secondary: #2a2a2a;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --text-muted: #757575;
            --heading-color: #e0e0e0;
            --border-primary: #383838;
            --border-secondary: #505050;
            --accent-blue: #7aa0b2;
            --accent-blue-hover: #95b9cd;
            --accent-green: #87c7a8;
            --accent-orange: #eaa67a;
            --accent-red: #e08484;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --focus-ring: rgba(122, 160, 178, 0.3);
            --modal-bg: #2a2a2a;
            --card-answer-bg: rgba(42, 42, 42, 0.9);
            --toggle-icon-color: #e0e0e0;
            --toggle-moon-mask: #1e1e1e;
        }

        .flashcard-title, .start-title {
            font-family: "Germgoth", serif;
            color: var(--heading-color);
            font-weight: normal;
            letter-spacing: 0.5px;
            text-align: center;
            padding-bottom: 5px;
            transition: color 0.4s ease;
        }
        .start-title {
            font-size: 2.8rem;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }
        .start-title::before {
            content: '';
            position: absolute;
            top: 0;
            left: -30%;
            width: 60%;
            height: 100%;
            background: linear-gradient(to right, transparent, rgba(255,255,255,0.4), transparent);
            transform: skewX(-20deg);
            animation: shine 2.5s infinite;
            filter: blur(4px);
        }
        body.dark-mode .start-title::before {
            background: linear-gradient(to right, transparent, rgba(30,30,30,0.4), transparent);

        }
        .flashcard-title {
            font-size: 1.8rem;
            margin-bottom: 15px;
        }

        .start-screen {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            opacity: 0;
            animation: fadeIn 0.8s ease-out forwards;
            position: relative;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes pulse {
            0%   { box-shadow: 0 0 10px var(--accent-blue); }
            50%  { box-shadow: 0 0 20px var(--accent-blue-hover); }
            100% { box-shadow: 0 0 10px var(--accent-blue); }
        }

        @keyframes shine {
            0%   { left: -50%; }
            100% { left: 150%; }
        }
        .start-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: flex-start;
            margin-bottom: 20px;
            position: relative;
        }

        .start-button {
            padding: 14px 30px;
            font-size: 1.1rem;
            font-weight: 500;
            background-color: var(--accent-blue);
            color: var(--bg-secondary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 5px var(--shadow-color);
            animation: pulse 2s ease-in-out infinite;
        }
        .start-button:hover {
            background-color: var(--accent-blue-hover);
            box-shadow: 0 4px 8px var(--shadow-color);
            transform: translateY(-2px);
        }
        .start-button:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px var(--shadow-color);
        }

        .dropdown-menu {
            position: relative;
            display: inline-block;
        }

        .dropdown-toggle {
            position: relative;
            padding-right: 45px;
        }

        .dropdown-toggle::after {
            content: '▲';
            font-size: 0.7em;
            position: absolute;
            right: 18px;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.3s ease;
        }

        .dropdown-menu:hover .dropdown-toggle::after,
        .dropdown-menu.active .dropdown-toggle::after {
            transform: translateY(-50%) rotate(180deg);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: var(--bg-secondary);
            min-width: 240px;
            box-shadow: 0 10px 25px var(--shadow-color);
            z-index: 10;
            border-radius: 8px;
            padding: 8px;
            bottom: 100%;
            left: 50%;
            margin-bottom: 8px;
            transform-origin: bottom center;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-blue) var(--bg-secondary);
        }

        .dropdown-content::-webkit-scrollbar {
            width: 8px;
        }

        .dropdown-content::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .dropdown-content::-webkit-scrollbar-thumb {
            background-color: var(--accent-blue);
            border-radius: 4px;
            border: 2px solid var(--bg-secondary);
        }

        .dropdown-content::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-blue-hover);
        }


        .dropdown-menu:hover .dropdown-content,
        .dropdown-menu.active .dropdown-content {
            display: block;
            opacity: 0;
            animation: elegantDropdownAppear 0.4s cubic-bezier(0.23, 1, 0.32, 1) forwards;
        }

        @keyframes elegantDropdownAppear {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px) scaleY(0.85);
            }
            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scaleY(1);
            }
        }

        .dropdown-item {
            width: 100%;
            padding: 10px 15px;
            text-decoration: none;
            display: block;
            background-color: transparent;
            border: none;
            color: var(--text-primary);
            text-align: left;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            transition: background-color 0.2s ease, color 0.2s ease, transform 0.2s ease;
        }

        .dropdown-item:not(:last-child) {
            margin-bottom: 4px;
        }

        .dropdown-item:hover {
            background-color: var(--accent-blue-hover);
            color: var(--bg-secondary);
            transform: none;
        }


        .footer {
            position: absolute;
            bottom: 15px;
            width: 100%;
            text-align: center;
            font-size: 0.85rem;
            color: var(--text-muted);
            transition: color 0.4s ease;
        }
        .footer a {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.3s ease;
        }
        .footer a:hover {
            color: var(--accent-blue-hover);
            text-decoration: none;
        }

        .day-night-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: transform 0.3s ease;
        }
        .day-night-toggle:focus {
            outline: none;
        }
        .day-night-toggle:hover {
            transform: scale(1.1);
        }

        .toggle-icon {
            width: 32px;
            height: 32px;
            overflow: visible;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .toggle-icon .icon-shape {
            fill: var(--toggle-icon-color);
            transition: fill 0.4s ease;
        }
        .toggle-icon .sun-ray {
            stroke: var(--toggle-icon-color);
            stroke-width: 4;
            stroke-linecap: round;
            transition: stroke 0.4s ease, opacity 0.5s ease;
        }
        .toggle-icon .moon-mask {
            fill: var(--toggle-moon-mask);
            transition: fill 0.4s ease;
        }

        .toggle-icon.rotate {
            transform: rotate(180deg);
        }
        .toggle-icon .sun-rays {
            opacity: 1;
            transition: opacity 0.5s 0.1s ease;
        }
        .toggle-icon .moon-group {
            opacity: 1;
            transition: opacity 0.5s 0.1s ease;
        }

        .toggle-icon.night .sun-rays {
            opacity: 0;
        }
        .toggle-icon.day .moon-group {
            opacity: 0;
        }

        .flashcard-container {
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            background-color: var(--bg-primary);
            padding: 25px;
            position: relative;
            max-width: 1400px;
            margin: 0 auto;
            opacity: 0;
            animation: fadeIn 0.6s 0.2s ease-out forwards;
            transition: background-color 0.4s ease;
        }
        .progress {
            display: flex;
            justify-content: space-between;
            margin-bottom: 18px;
            gap: 15px;
        }
        .progress-item {
            display: flex;
            align-items: center;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: 500;
            background-color: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.3s ease, transform 0.2s ease, background-color 0.3s ease, border-color 0.3s ease;
            border: 1px solid var(--border-primary);
            flex-shrink: 0;
        }
        @media screen and (max-width: 768px) {
            .progress-item span {
                white-space: nowrap;
                flex-shrink: 0;
            }
        }
        .progress-item:hover {
            background-color: var(--bg-secondary);
            border-color: var(--border-secondary);
            transform: scale(1.03);
        }
        .progress-number-orange {
            margin-right: 8px;
            color: var(--accent-orange);
            font-weight: 600;
            font-size: 1rem;
        }
        .progress-number-green {
            margin-left: 8px;
            color: var(--accent-green);
            font-weight: 600;
            font-size: 1rem;
        }

        .card-content {
            position: relative;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            margin-bottom: 20px;
            border-radius: 10px;
            background-color: var(--bg-secondary);
            box-shadow: 0 4px 15px var(--shadow-color);
            border: 1px solid var(--border-primary);
            transition: background-color 0.4s ease, box-shadow 0.4s ease, border-color 0.4s ease;
        }
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(var(--bg-secondary-rgb, 255, 255, 255), 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
            border-radius: 10px;
            transition: background-color 0.4s ease, opacity 0.3s ease-out;
        }
        body.dark-mode .loading-screen {
            --bg-secondary-rgb: 42, 42, 42;
        }
        .spinner {
            border: 4px solid var(--border-primary);
            border-top: 4px solid var(--accent-blue);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
            transition: border-color 0.4s ease;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .card-content img {
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transition: opacity 0.5s ease-in-out;
            opacity: 0;
            border-radius: 10px;
        }
        .card-content img.loaded {
            opacity: 1;
        }

        .your-answer-label {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding-left: 5px;
            transition: visibility 0s linear 0.3s, opacity 0.3s ease, color 0.4s ease;
        }
        .answer-input-container {
            margin-bottom: 20px;
            transition: visibility 0s linear 0.3s, opacity 0.3s ease;
        }
        .answer-input {
            width: 100%;
            padding: 14px 18px;
            font-size: 1rem;
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease, background-color 0.4s ease, color 0.4s ease;
            appearance: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05) inset;
        }
        .answer-input::placeholder {
            color: var(--text-muted);
            font-weight: 400;
            transition: color 0.4s ease;
        }
        .answer-input:focus {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--focus-ring), 0 1px 3px rgba(0, 0, 0, 0.05) inset;
        }

        .bottom-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            transition: visibility 0s linear 0.3s, opacity 0.3s ease;
        }
        .dont-know-button, .answer-button {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
        }
        .dont-know-button {
            background-color: transparent;
            color: var(--accent-blue);
            border: 1px solid transparent;
        }
        .dont-know-button:hover {
            color: var(--accent-blue-hover);
            background-color: rgba(var(--accent-blue-rgb, 109, 138, 150), 0.08);
            transform: scale(1.02);
        }
        body.dark-mode .dont-know-button:hover {
            --accent-blue-rgb: 122, 160, 178;
        }
        .answer-button {
            background-color: var(--accent-blue);
            color: var(--bg-secondary);
            box-shadow: 0 2px 5px var(--shadow-color);
        }
        .answer-button:hover {
            background-color: var(--accent-blue-hover);
            box-shadow: 0 4px 8px var(--shadow-color);
            transform: translateY(-2px);
        }
        .dont-know-button:active, .answer-button:active {
            transform: scale(0.98);
            box-shadow: 0 1px 3px var(--shadow-color);
        }

        .card-answer {
            display: none;
            position: absolute;
            bottom: 25px;
            left: 25px;
            right: 25px;
            background-color: var(--card-answer-bg);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 20px;
            border-radius: 10px;
            border: none;
            font-size: 1rem;
            z-index: 3;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 5px 20px var(--shadow-color);
            opacity: 0;
            transform: translateY(10px);
            animation: fadeSlideIn 0.4s ease-out forwards;
            color: var(--text-primary);
            text-align: center;
            transition: background-color 0.4s ease, color 0.4s ease, box-shadow 0.4s ease;
        }
        @keyframes fadeSlideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        #showAnswer strong {
            font-weight: 600;
            margin-right: 5px;
        }
        #showAnswer strong[style*="#10B981"] {
            color: var(--accent-green) !important;
        }
        #showAnswer strong[style*="#EF4444"] {
            color: var(--accent-red) !important;
        }
        #showAnswer strong[style*="#F59E0B"] {
            color: var(--accent-orange) !important;
        }

        #showExplanation {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-top: 5px;
            max-height: 100px;
            overflow-y: auto;
            overflow: visible;
            transition: color 0.4s ease;
        }
        #showExplanation strong {
            font-weight: 600;
            color: var(--text-primary);
            transition: color 0.4s ease;
        }
        #showExplanation .contribute-link {
            color: var(--accent-blue);
            cursor: pointer;
            text-decoration: underline;
            font-weight: 500;
            margin-left: 5px;
            transition: color 0.3s ease;
        }
        #showExplanation .contribute-link:hover {
            color: var(--accent-blue-hover);
        }

        .contribution-area {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-primary);
            display: flex;
            transition: border-color 0.4s ease;
        }
        .contribution-area input {
            flex: 1;
            padding: 8px 12px;
            font-size: 1rem;
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            outline: none;
            resize: vertical;
            margin-right: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05) inset;
            transition: background-color 0.4s ease, color 0.4s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .contribution-area input:focus {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--focus-ring), 0 1px 3px rgba(0, 0, 0, 0.05) inset;
        }
        .contribution-area button {
            padding: 8px 18px;
            font-size: 1rem;
            font-weight: 500;
            background-color: var(--accent-blue);
            color: var(--bg-secondary);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease;
            float: right;
        }
        .contribution-area button:hover {
            background-color: var(--accent-blue-hover);
        }
        .contribution-area button:active {
            transform: scale(0.97);
        }
        .contribution-area button.loading {
            position: relative;
            color: transparent !important;
            pointer-events: none;
        }
        .contribution-area button.loading::after {
            content: '';
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            margin-top: -8px;
            margin-left: -8px;
            border: 2px solid rgba(var(--bg-secondary-rgb, 255, 255, 255), 0.4);
            border-top-color: var(--bg-secondary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            transition: border-color 0.4s ease;
        }
        body.dark-mode .contribution-area button.loading::after {
            --bg-secondary-rgb: 42, 42, 42;
            border-top-color: var(--bg-secondary);
        }

        .next-button {
            display: block;
            padding: 10px 22px;
            font-size: 1rem;
            font-weight: 500;
            background-color: transparent;
            color: var(--accent-blue);
            border: 1px solid var(--accent-blue);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            align-self: center;
            margin-top: 15px;
        }
        .next-button:hover {
            background-color: var(--accent-blue);
            color: var(--bg-secondary);
            border-color: var(--accent-blue);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(var(--accent-blue-rgb, 109, 138, 150), 0.2);
        }
        body.dark-mode .next-button:hover {
            --accent-blue-rgb: 122, 160, 178;
        }
        .next-button:active {
            transform: scale(0.97);
            box-shadow: none;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            justify-content: center;
            align-items: center;
            opacity: 0;
            animation: fadeInModal 0.4s ease forwards;
            transition: background-color 0.4s ease;
        }
        @keyframes fadeInModal {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal-content {
            width: 90%;
            max-width: 650px;
            max-height: 85%;
            overflow-y: auto;
            background-color: var(--modal-bg);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 30px var(--shadow-color);
            position: relative;
            transform: scale(0.95);
            animation: scaleUpModal 0.4s ease forwards;
            transition: background-color 0.4s ease, box-shadow 0.4s ease, border-color 0.4s ease;
            border: 1px solid var(--border-primary);
        }
        #imageModal .modal-content {
            overflow: visible !important;
            scrollbar-width: none;
        }
        #imageModal .modal-content::-webkit-scrollbar {
            display: none;
        }
        .nav-button {
            all: unset;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            pointer-events: auto;
            color: var(--text-primary);
            font-size: 2rem;
            line-height: 1;
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            opacity: 0.6;
            transition: opacity 0.3s ease, transform 0.3s ease, color 0.3s ease;
        }
        .nav-left { left: -80px; }
        .nav-right { right: -80px; }
         @keyframes scaleUpModal {
            from { transform: scale(0.95); opacity: 0;}
            to { transform: scale(1); opacity: 1;}
         }
        .close {
            position: absolute;
            top: 13px;
            right: 20px;
            font-size: 2rem;
            font-weight: 300;
            color: var(--text-secondary);
            cursor: pointer;
            line-height: 1;
            transition: color 0.3s ease, transform 0.3s ease;
        }
        .close:hover {
            color: var(--accent-blue-hover);
            transform: rotate(90deg);
        }
        .modal-content h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--heading-color);
            font-weight: 600;
            border-bottom: 1px solid var(--border-primary);
            padding-bottom: 10px;
            transition: color 0.4s ease, border-color 0.4s ease;
        }
        .modal-content p {
            font-size: 1rem;
            line-height: 1.7;
            margin-bottom: 15px;
            color: var(--text-primary);
            transition: color 0.4s ease;
        }
        .modal-content ol {
            padding-left: 25px;
            margin-bottom: 16px;
        }
        .modal-content li {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-primary);
            list-style-type: decimal;
            transition: border-color 0.4s ease;
        }
        .modal-content li:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .modal-content li p {
            margin-bottom: 8px;
        }
        .modal-content li p strong {
            color: var(--text-primary);
        }
        .modal-content li em {
            color: var(--text-secondary);
        }
        .modal-content img {
            max-width: 150px;
            height: auto;
            margin-bottom: 12px;
            border-radius: 6px;
            border: 1px solid var(--border-primary);
            display: block;
            box-shadow: 0 2px 5px var(--shadow-color);
            background-color: var(--bg-secondary);
            transition: border-color 0.4s ease, box-shadow 0.4s ease, background-color 0.4s ease;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        .answer-input-container[style*="hidden"],
        .bottom-buttons[style*="hidden"],
        .your-answer-label[style*="hidden"] {
            opacity: 0;
            visibility: hidden;
            transition: visibility 0s linear 0.3s, opacity 0.3s ease;
        }

        .player-input {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            margin-bottom: 24px;
        }
        .player-input input {
            width: 100%;
            padding: 10px 16px;
            font-size: 1rem;
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            transition: border-color .3s ease, box-shadow .3s ease;
        }
        .player-input input:focus {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--focus-ring);
            outline: none;
        }

        .leaderboard {
            width: 100%;
            max-width: 400px;
            margin: 0 0 20px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            box-shadow: 0 2px 6px var(--shadow-color);
            padding: 20px 20px 0;
            max-height: 250px;
            overflow: hidden;
            transition: max-height 0.5s ease 0.5s;
            cursor: pointer;
            position: relative;
        }
        .leaderboard::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40px;
            pointer-events: none;
            background: linear-gradient(transparent, var(--bg-secondary));
            opacity: 1;
            transition: opacity 0.3s ease 0.5s;
        }
        .leaderboard h3 {
            margin-bottom: 12px;
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--heading-color);
        }
        .leaderboard ol {
            padding-left: 0;
            margin: 0;
        }
        .leaderboard li {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-primary);
        }
        .leaderboard-rank {
            width: 30px;
            text-align: left;
        }
        .leaderboard-name {
            flex: 1;
            text-align: center;
        }
        .leaderboard-score {
            width: 50px;
            text-align: right;
        }
        .leaderboard li:last-child {
            border-bottom: none;
        }
        .leaderboard li.current-user {
            font-weight: 600;
            color: var(--accent-blue);
        }

         .leaderboard.expanded {
             max-height: 500px;
         }
         .leaderboard.expanded::after {
             opacity: 0;
             transition-delay: 0s;
         }
        .leaderboard:hover {
            max-height: 500px;
            transition-delay: 0s;
        }
        .leaderboard:hover::after {
            opacity: 0;
            transition-delay: 0s;
        }
        .tooltip {
            position: absolute;
            bottom: calc(100% + 6px);
            left: 50%;
            transform: translateX(-22%);
            background-color: #000;
            color: #fff;
            padding: 8px 16px;
            border-radius: 999px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 3000;
        }
        .tooltip-arrow {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-22%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid #000;
        }
        #no-explanation-message .tooltip {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        #no-explanation-message:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        .alert-modal {
            display: none;
            background-color: var(--modal-bg);
            color: var(--text-primary);
            padding: 20px;
            border-radius: 8px;
            max-width: 90%;
            width: 400px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            position: absolute;
            top: 20px;
            left: 50%;
            translate: -50%;
        }
        .nav-button {
            background-color: transparent;
            width: auto;
            height: auto;
            color: var(--text-primary);
            font-size: 2rem;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            pointer-events: auto;
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 3010;
            border: none;
            outline: none;
            opacity: 0.6;
            appearance: none;
            padding: 0;
        }

        .nav-left { left: -80px; }
        .nav-right { right: -80px; }

        .nav-button::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            background: var(--accent-blue);
            border-radius: 50%;
            opacity: 0;
            transition: width 0.3s ease, height 0.3s ease, opacity 0.3s ease, filter 0.3s ease;
            pointer-events: none;
        }
        .nav-button:hover {
            color: var(--accent-blue);
        }
        .nav-button:hover::before {
            width: 80px;
            height: 80px;
            opacity: 0.4;
            filter: blur(10px);
        }
        @media screen and (max-width: 768px) {
            .progress {
                gap: 0;
            }
            .dropdown-menu.active .dropdown-content {
                display: block;
                opacity: 1;
                visibility: visible;
                transform: translateX(-50%) translateY(0) scaleY(1);
                animation: elegantDropdownAppear 0.4s cubic-bezier(0.23, 1, 0.32, 1) forwards;
            }
            #wrongArea span:not(.progress-number-orange),
            #correctArea span:not(.progress-number-green) {
                display: none;
            }
            .progress-number-green {
                margin-left: 0;
            }
            .progress-number-orange {
                margin-right: 0;
            }
        }
    </style>
</head>
<body onload="init();">

    <div class="start-screen">
        <button id="dayNightToggle" class="day-night-toggle" aria-label="切換到夜晚模式">
            <svg id="dayNightIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="toggle-icon day">
            </svg>
        </button>

        <div class="start-title">Parasitology</div>
          <div class="leaderboard">
            <ol id="boardList" style="list-style:decimal inside; padding:0;"></ol>
          </div>
          <div class="player-input" style="text-align:center;">
            <input type="text" id="playerName" placeholder="輸入玩家名稱">
          </div>
    <div class="start-buttons">
      <button id="startAllGame" class="start-button">全部</button>
      <div class="dropdown-menu">
          <button class="dropdown-toggle start-button">單元</button>
          <div class="dropdown-content">
              <button class="dropdown-item" data-json="egg.json">蟲卵</button>
              <button class="dropdown-item" data-json="線蟲.json">線蟲</button>
              <button class="dropdown-item" data-json="吸蟲.json">吸蟲</button>
              <button class="dropdown-item" data-json="絛蟲.json">絛蟲</button>
              <button class="dropdown-item" data-json="原蟲.json">原蟲</button>
              <button class="dropdown-item" data-json="舌蟲、蛭類、節肢動物.json">舌蟲、蛭類、節肢動物</button>
          </div>
      </div>
      <button id="openDoc" class="start-button">題庫</button>
    </div>
    <div class="progress-actions" style="text-align:center; margin-top:10px; display:none;">
      <button id="resumeButton" class="start-button" style="background-color: var(--accent-green); display:none;">接續上次</button>
      <div style="margin-top:8px;">
        <span id="restartProgress" style="color:#999;text-decoration:underline;cursor:pointer;">重新開始</span>
      </div>
    </div>
        <div class="footer">
          <a href="https://christmaskid.github.io/parasite_game/" target="_blank">前往舊版</a> ｜
          <a href="https://chromewebstore.google.com/detail/%E5%8F%B0%E5%A4%A7%E9%86%AB%E5%A1%AB%E5%95%8F%E5%8D%B7/ciioeecbkbnmnedkgmkfaicngidogdkj?authuser=0&hl=en" target="_blank">問卷外掛</a> ｜
          <span id="download-block">
            <a href="profile.mobileconfig" download="Parasite.mobileconfig">蘋果下載</a> ｜
          </span>
          <a href="https://line.me/ti/p/~jedieason" target="_blank">問題回報</a>
        </div>
    </div>

    <div class="flashcard-container">
         <div class="progress">
            <div class="progress-item" id="wrongArea">
                <span class="progress-number-orange" id="wrong">0</span>
                <span>錯誤</span>
            </div>
            <div class="progress-item" style="border:none; cursor:default;">
                <span>分數：</span>
                <span id="score-display">0</span>
                <span style="margin: 0 5px;">｜</span>
                <span>排名：</span>
                <span id="rank-display">N/A</span>
            </div>
            <div class="progress-item" id="correctArea">
                <span>正確</span>
                <span class="progress-number-green" id="correct">0</span>
            </div>
        </div>

        <div class="card-content">
            <div class="loading-screen">
                <div class="spinner"></div>
            </div>
            <img id="image" onload="this.classList.add('loaded'); document.querySelector('.loading-screen').style.display='none'; preloadNextImage();" src="" alt="Parasite Image">
        </div>

        <div class="card-answer">
            <div id="showAnswer"></div>
            <div id="showExplanation">
            </div>
            <button id="next" class="next-button">下一個</button>
        </div>

        <div class="your-answer-label">這是什麼？</div>
        <div class="answer-input-container">
            <input id="answer" type="text" placeholder="把答案打在這" class="answer-input">
        </div>

        <div class="bottom-buttons">
            <button id="dontKnow" class="dont-know-button">母災</button>
            <button id="submitAnswer" class="answer-button">確定</button>
        </div>
    </div>
    <div id="modal" class="modal">
        <div class="modal-content">
            <span id="closeModal" class="close">×</span>
            <div id="modalBody"></div>
        </div>
    </div>
    <div id="alertModal" class="alert-modal" style="display: none;">
        <span class="close" onclick="closeAlertModal()">×</span>
        <div id="alertModalBody"></div>
    </div>
    <div id="docContainer" class="doc-container" style="display:none;">
      <div class="doc-page">
        <span id="closeDoc" class="close">&times;</span>
        <div id="docContent"></div>
      </div>
    </div>

    <div id="imageModal" class="modal" style="z-index:3000;">
      <div class="modal-content">
        <span id="closeImageModal" class="close" style="top: 4px; right: 10px;">&times;</span>
        <button id="prevImageButton" class="nav-button nav-left" aria-label="上一題">‹</button>
        <button id="nextImageButton" class="nav-button nav-right" aria-label="下一題">›</button>
        <img id="modalImage" src="" alt="Image preview" style="max-width: 100%; height: auto; border-radius:6px;">
        <div id="modalInfo" style="text-align:center;">
          <p id="modalAnswer" style="font-weight:600;"></p>
          <p id="modalExplanation" style="color:var(--text-secondary); margin-bottom: 0;"></p>
        </div>
      </div>
    </div>

    <script type="module">
        let isComposing = false;
        document.addEventListener('compositionstart', () => { isComposing = true; });
        document.addEventListener('compositionend', () => { isComposing = false; });

        const firebaseConfig = {
            apiKey: "AIzaSyAjvO8nSRkKXUp7gopj-X7QsOGRBHTxj1s",
            authDomain: "jedieason-trivia.firebaseapp.com",
            databaseURL: "https://jedieason-trivia-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "jedieason-trivia",
            storageBucket: "jedieason-trivia.firebasestorage.app",
            messagingSenderId: "379460583179",
            appId: "1:379460583179:web:c9d36892128bb0ac066c0e",
            measurementId: "G-5NK671LL2Z"
        };
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-app.js";
        import { getAnalytics }  from "https://www.gstatic.com/firebasejs/9.17.1/firebase-analytics.js";
        import {
            getDatabase,
            ref,
            query,
            orderByChild,
            limitToLast,
            get,
            set
        } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-database.js";
        import {
            getAuth,
            signInAnonymously,
            onAuthStateChanged
        } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-auth.js";

        const app       = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const db        = getDatabase(app);
        const auth = getAuth(app);
        signInAnonymously(auth).catch(err => console.error("匿名登入失敗：", err));
        onAuthStateChanged(auth, user => {
            if (user) {
                window.currentUserUid = user.uid;
            } else {
                window.currentUserUid = null;
            }
        });

        window.currentPlayer = "匿名";
        var TIME = 31;
        var numOfProbs; // Length of currentQuestionSet
        var tm;
        // var data; // Replaced by currentQuestionSet and allQuestions
        var x; // Index for currentQuestionSet
        var state = 0; // Original usage unclear, may not be needed or needs review
        var correct = 0; // Round-specific
        var wrong = 0;   // Round-specific
        var total = 0; // Original usage unclear, seems like round question count
        var viewing = false; // If answer card is being shown
        var done; // Boolean array for currentQuestionSet
        var score = 0; // Global score, persisted as window.score
        var correctList = []; // Round-specific
        var wrongList = [];   // Round-specific

        // New state variables for replay mistakes feature
        let allQuestions = []; // Full deck loaded from JSON for the current game type
        let currentQuestionSet = []; // Questions for the active round (either allQuestions or pendingMistakesForNextRound)
        let isReplaying = false; // True if currently in a "replay mistakes" round
        let pendingMistakesForNextRound = []; // Mistakes from a completed round, to be used for the next replay
        let currentJsonPath = ""; // Path of the JSON file for the current game (e.g., "./all.json")
        let viewingState = false; // Saved viewing state for resume

        const lowerCaseSwearWords = [
            "幹", "靠", "操", "媽的", "他媽的", "幹你娘", "機掰", "雞掰", "哭邀", "靠北", "靠腰",
            "操你媽", "王八蛋", "他媽", "賤人", "婊子", "俗辣", "垃圾", "智障", "白痴", "腦殘",
            "低能", "肏", "淦", "靠杯", "三小", "啥小", "死", "屁", "幹您娘", "操機掰", "娘砲", "破麻",
            "操你妈", "干", "他妈", "傻逼", "脑残", "屌",
            "fuck", "fucking", "shit", "bitch", "damn", "asshole", "cunt", "fucker", "motherfucker",
            "dick", "pussy", "wank", "slut", "whore"
        ].map(word => word.toLowerCase());

        const dayNightToggle = document.getElementById('dayNightToggle');
        const dayNightIcon = document.getElementById('dayNightIcon');
        let isDay = true;
        window.gameplayActive = false;

        function renderSun() {
            dayNightIcon.innerHTML = `
                <circle cx="50" cy="50" r="20" class="icon-shape" />
                <g class="sun-rays">
                    ${[...Array(8)].map((_, i) => {
                        const angle = (i * 45) * (Math.PI / 180);
                        const x1 = 50 + Math.cos(angle) * 30;
                        const y1 = 50 + Math.sin(angle) * 30;
                        const x2 = 50 + Math.cos(angle) * 38;
                        const y2 = 50 + Math.sin(angle) * 38;
                        return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" class="sun-ray" />`;
                    }).join('')}
                </g>
                <g class="moon-group" style="opacity: 0;">
                    <circle cx="50" cy="50" r="20" class="icon-shape" />
                    <circle cx="58" cy="50" r="18" class="moon-mask" />
                </g>
            `;
            dayNightIcon.classList.remove('night');
            dayNightIcon.classList.add('day');
            dayNightIcon.classList.remove('rotate');
        }
        window.init = init;

        function renderMoon() {
            dayNightIcon.innerHTML = `
                 <circle cx="50" cy="50" r="20" class="icon-shape" style="fill: none;"/>
                 <g class="sun-rays" style="opacity: 0;">
                     ${[...Array(8)].map((_, i) => {
                         const angle = (i * 45) * (Math.PI / 180);
                         const x1 = 50 + Math.cos(angle) * 30;
                         const y1 = 50 + Math.sin(angle) * 30;
                         const x2 = 50 + Math.cos(angle) * 38;
                         const y2 = 50 + Math.sin(angle) * 38;
                         return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" class="sun-ray" />`;
                     }).join('')}
                 </g>
                 <g class="moon-group">
                     <circle cx="50" cy="50" r="20" class="icon-shape" />
                     <circle cx="58" cy="50" r="18" class="moon-mask" />
                 </g>
            `;
            dayNightIcon.classList.remove('day');
            dayNightIcon.classList.add('night');
            dayNightIcon.classList.add('rotate');
        }

        let availableVoices = [];
        function populateVoices() {
            availableVoices = speechSynthesis.getVoices();
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = () => {
                    availableVoices = speechSynthesis.getVoices();
                };
            }
        }

        function addOrUpdateSpeakButton(answerToSpeak, answerDisplayElement) {
            let existingSpeakButton = answerDisplayElement.querySelector('.speak-answer-icon-button');
            if (existingSpeakButton) {
                existingSpeakButton.remove();
            }

            const speakButton = document.createElement('button');
            speakButton.className = 'speak-answer-icon-button';
            speakButton.setAttribute('aria-label', 'Play answer');
            speakButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="rgb(102, 102, 102)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle;">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                    <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                </svg>
            `;
            speakButton.style.background = 'none';
            speakButton.style.border = 'none';
            speakButton.style.padding = '0 0 0 8px';
            speakButton.style.cursor = 'pointer';
            speakButton.style.display = 'inline-flex';
            speakButton.style.alignItems = 'center';
            speakButton.style.verticalAlign = 'middle';


            speakButton.onclick = (event) => {
                event.stopPropagation();
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                }
                const utterance = new SpeechSynthesisUtterance(answerToSpeak);
                let targetVoice = availableVoices.find(voice => voice.lang.startsWith('en') && (voice.name.toLowerCase().includes('google') || voice.name.toLowerCase().includes('natural')));
                if (!targetVoice) {
                    targetVoice = availableVoices.find(voice => voice.lang.startsWith('en'));
                }
                if (targetVoice) {
                    utterance.voice = targetVoice;
                }
                speechSynthesis.speak(utterance);
            };

            answerDisplayElement.appendChild(speakButton);
        }

        function toggleTheme() {
            isDay = !isDay;
            if (isDay) {
                document.body.classList.remove('dark-mode');
                renderSun();
                dayNightToggle.setAttribute('aria-label', '切換到夜晚模式');
            } else {
                document.body.classList.add('dark-mode');
                renderMoon();
                dayNightToggle.setAttribute('aria-label', '切換到白天模式');
            }
            const bodyStyles = window.getComputedStyle(document.body);
            document.documentElement.style.setProperty('--toggle-moon-mask', bodyStyles.getPropertyValue('--bg-primary'));
        }

        function initDayNightToggle() {
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            isDay = !prefersDark;

            if (isDay) {
                renderSun();
                document.body.classList.remove('dark-mode');
                dayNightToggle.setAttribute('aria-label', '切換到夜晚模式');
            } else {
                renderMoon();
                document.body.classList.add('dark-mode');
                dayNightToggle.setAttribute('aria-label', '切換到白天模式');
            }
            const bodyStyles = window.getComputedStyle(document.body);
            document.documentElement.style.setProperty('--toggle-moon-mask', bodyStyles.getPropertyValue('--bg-primary'));

            dayNightToggle.addEventListener('click', toggleTheme);

             window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                isDay = !event.matches;
                 if (isDay) {
                     document.body.classList.remove('dark-mode');
                     renderSun();
                     dayNightToggle.setAttribute('aria-label', '切換到夜晚模式');
                 } else {
                     document.body.classList.add('dark-mode');
                     renderMoon();
                     dayNightToggle.setAttribute('aria-label', '切換到白天模式');
                 }
                 const bodyStyles = window.getComputedStyle(document.body);
                 document.documentElement.style.setProperty('--toggle-moon-mask', bodyStyles.getPropertyValue('--bg-primary'));
             });
        }
        async function writeScore(finalScore) {
            const uid = window.currentUserUid;
            if (!uid) throw new Error("使用者尚未登入");
            const scoreRef = ref(db, `leaderboard/${uid}`);
            try {
                const snap = await get(scoreRef);
                const prev = snap.val();
                const prevScore = prev && typeof prev.score === 'number' ? prev.score : 0;
                const newScore = prevScore + finalScore;
                await set(scoreRef, {
                    name: window.currentPlayer,
                    score: newScore,
                    timestamp: Date.now()
                });
                return newScore; // Return the new total score in Firebase
            } catch (err) {
                console.error("寫入分數失敗：", err);
                throw err;
            }
        }

        async function fetchLeaderboard() {
            const listEl = document.getElementById("boardList");
            listEl.innerHTML = '<li>載入中…</li>';

            try {
                const snap = await get(ref(db, 'leaderboard'));
                const dataObj = snap.val() || {};
                const entries = Object.entries(dataObj).map(([uid, item]) => ({ uid, ...item }));
                const sorted = entries.sort((a, b) => b.score - a.score);

                listEl.innerHTML = '';
                let inTop = false;
                let prevScoreVal = null; // Renamed to avoid conflict with global score
                let prevRank = 0;
                sorted.forEach((item, index) => {
                    if (index < 10) {
                        const li = document.createElement('li');
                        if (item.uid === window.currentUserUid) li.classList.add('current-user');
                        const rankSpan = document.createElement('span');
                        rankSpan.className = 'leaderboard-rank';
                        let rank;
                        if (item.score === prevScoreVal) {
                            rank = prevRank;
                        } else {
                            rank = index + 1;
                            prevScoreVal = item.score;
                            prevRank = rank;
                        }
                        rankSpan.textContent = rank;
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'leaderboard-name';
                        nameSpan.textContent = item.name;
                        const scoreSpan = document.createElement('span');
                        scoreSpan.className = 'leaderboard-score';
                        scoreSpan.textContent = item.score;
                        li.append(rankSpan, nameSpan, scoreSpan);
                        listEl.appendChild(li);
                        if (item.uid === window.currentUserUid) inTop = true;
                    }
                });
                if (!inTop) {
                    const userIndex = sorted.findIndex(item => item.uid === window.currentUserUid);
                    if (userIndex !== -1) {
                        const item = sorted[userIndex];
                        const li = document.createElement('li');
                        li.classList.add('current-user');
                        const rankSpan = document.createElement('span');
                        rankSpan.className = 'leaderboard-rank';
                        let userActualRank = 0;
                        let scoreForPrevRank = null;
                        let runningRankForUser = 0;
                        for(let i=0; i < sorted.length; i++) {
                            if (sorted[i].score !== scoreForPrevRank) {
                                runningRankForUser = i + 1;
                                scoreForPrevRank = sorted[i].score;
                            }
                            if (sorted[i].uid === window.currentUserUid) {
                                userActualRank = runningRankForUser;
                                break;
                            }
                        }
                        rankSpan.textContent = userActualRank || (sorted.filter(it => it.score > item.score).length + 1);
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'leaderboard-name';
                        nameSpan.textContent = item.name;
                        const scoreSpan = document.createElement('span');
                        scoreSpan.className = 'leaderboard-score';
                        scoreSpan.textContent = item.score;
                        li.append(rankSpan, nameSpan, scoreSpan);
                        listEl.appendChild(li);
                    }
                }
                const playerData = sorted.find(item => item.uid === window.currentUserUid);
                // window.score should be the game's internal global score, not directly from leaderboard here.
                // Leaderboard score is fetched, but game's window.score is the source of truth during gameplay.
                // If resuming, window.score is loaded from localStorage.
                // If starting new, window.score might be 0 or from previous Firebase state if not reset.
                // For now, let's assume window.score is managed correctly elsewhere.
                // document.getElementById("score-display").textContent = window.score; // Use window.score

                const rankDisplay = document.getElementById("rank-display");
                if (rankDisplay) {
                    if (playerData) {
                        let userDisplayRank = "N/A";
                        let currentOverallRank = 0;
                        let scoreForLastOverallRank = null;
                        for (let i = 0; i < sorted.length; i++) {
                            const entry = sorted[i];
                            if (entry.score !== scoreForLastOverallRank) {
                                currentOverallRank = i + 1;
                                scoreForLastOverallRank = entry.score;
                            }
                            if (entry.uid === window.currentUserUid) {
                                userDisplayRank = currentOverallRank;
                                break;
                            }
                        }
                        rankDisplay.textContent = userDisplayRank;
                    } else {
                        rankDisplay.textContent = "N/A";
                    }
                }
            } catch (err) {
                console.error("讀排行榜失敗：", err);
                listEl.innerHTML = '<li>讀取失敗</li>';
                const rankDisplay = document.getElementById("rank-display");
                if (rankDisplay) rankDisplay.textContent = "N/A";
            }
        }

        function updateCorrect() {
            correct++; // Round-specific
            document.getElementById("correct").innerText = correct;
            const pointsEarned = 2;
            window.score += pointsEarned; // Update global score
            if (currentQuestionSet && currentQuestionSet[x]) {
                correctList.push(currentQuestionSet[x]);
            }
            updateScoreDisplay(); // Updates all score displays
            writeScore(pointsEarned) // This sends the delta to Firebase
                .then(() => fetchLeaderboard()) // Refresh leaderboard after score update
                .catch(err => console.error("寫入分數或更新排名失敗：", err));
        }
        function updateWrong() {
            wrong++; // Round-specific
            document.getElementById("wrong").innerText = wrong;
            const pointsLost = -2;
            window.score += pointsLost; // Update global score
            if (currentQuestionSet && currentQuestionSet[x]) {
                wrongList.push(currentQuestionSet[x]);
            }
            updateScoreDisplay();
            writeScore(pointsLost)
                .then(() => fetchLeaderboard())
                .catch(err => console.error("寫入分數或更新排名失敗：", err));
        }
        function updateUnknown(){
            wrong++; // Round-specific, counts as wrong for the round
            document.getElementById("wrong").innerText = wrong;
            const pointsLost = -1;
            window.score += pointsLost; // Update global score
            if (currentQuestionSet && currentQuestionSet[x]) {
                wrongList.push(currentQuestionSet[x]); // Add to wrongList for replay
            }
            updateScoreDisplay();
            writeScore(pointsLost)
                .then(() => fetchLeaderboard())
                .catch(err => console.error("寫入分數或更新排名失敗：", err));
        }

        // checkCompletion is effectively replaced by handleEndOfRound
        // function checkCompletion() {
        //     if (!done.every(x => x)) return;
        //     // This logic is now in handleEndOfRound
        // }

        function init() {
            console.log("[init] Initializing application.");
            initDayNightToggle();
            populateVoices();

            const savedName = localStorage.getItem("parasite_player_name");
            if (savedName) {
                const nameField = document.getElementById("playerName");
                if (nameField) nameField.value = savedName;
                window.currentPlayer = savedName; // Initialize currentPlayer
            }
            fetchLeaderboard(); // Initial fetch for start screen
            const leaderboardEl = document.querySelector('.leaderboard');
            if (leaderboardEl) {
                leaderboardEl.addEventListener('click', function() {
                    this.classList.toggle('expanded');
                });
            }

            document.addEventListener("keydown", function(e) {
                if (window.isComposing) return;

                if (e.key === "/") {
                    // ... (existing focus logic, seems fine) ...
                }
            });

            // Setup for start buttons
            document.getElementById("startAllGame").addEventListener("click", () => initializeNewGameSession("./all.json"));
            const dropdownItems = document.querySelectorAll(".dropdown-item");
            dropdownItems.forEach(item => {
                item.addEventListener("click", function() {
                    const jsonPath = this.dataset.json;
                    initializeNewGameSession(`./${jsonPath}`);
                    const dropdownMenuElement = this.closest('.dropdown-menu');
                    if (dropdownMenuElement && dropdownMenuElement.classList.contains('active')) {
                        dropdownMenuElement.classList.remove('active');
                    }
                });
            });


            const dropdownMenuToggle = document.querySelector('.dropdown-toggle');
            const dropdownMenuElement = document.querySelector('.dropdown-menu');

            if (dropdownMenuToggle && dropdownMenuElement) {
                // ... (existing dropdown logic, seems fine) ...
            }


            window.globalEnterPressStart = function (event) {
                if (event.key === 'Enter') {
                    if (window.isComposing) return;
                    if (window.gameplayActive) return; // Don't start new if game already active

                    const nameInput = document.getElementById("playerName").value.trim();
                    if (!nameInput) {
                        showAlertModal("請先輸入玩家名稱！");
                        document.getElementById("playerName").focus();
                        return;
                    }
                    const startScreen = document.querySelector('.start-screen');
                    if (startScreen && getComputedStyle(startScreen).display !== 'none') {
                        // Prefer "All" if on start screen and enter is pressed globally
                        initializeNewGameSession("./all.json");
                    }
                }
            };
            document.addEventListener("keypress", window.globalEnterPressStart);


            adjustPlaceholder();
            window.addEventListener('resize', adjustPlaceholder);

            document.getElementById("openDoc").addEventListener("click", function() {
                // ... (existing doc logic, seems fine) ...
            });
            // ... (other doc and image modal listeners, seem fine) ...


            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const link = document.querySelector('a[href="profile.mobileconfig"]');
            const downloadBlock = document.getElementById("download-block");
            // ... (download link logic, seems fine) ...


            // Event listeners for game interaction buttons (moved from old startGame)
            document.addEventListener("keydown", enterKeyEvent); // Global enter key for submit/next
            document.getElementById("submitAnswer").addEventListener("click", submitUserAnswer);
            document.getElementById("dontKnow").addEventListener("click", showAnswer); // "母災" button
            document.getElementById("correctArea").addEventListener("click", showCorrectList);
            document.getElementById("wrongArea").addEventListener("click", showWrongList);
            // The main "next" button's listener is set up separately for "下一個" / "重玩錯誤" logic
            document.getElementById('closeModal').addEventListener('click', function() {
                document.getElementById('modal').style.display = "none";
            });
            window.addEventListener('click', function(event) {
                let regularModal = document.getElementById('modal');
                if (event.target === regularModal) {
                    regularModal.style.display = "none";
                }
            });


            // Resume logic
            const savedProgString = localStorage.getItem('gameProgress');
            if (savedProgString) {
                try {
                    const prog = JSON.parse(savedProgString);
                    console.log("[Resume] Resuming progress from:", prog);

                    currentJsonPath = prog.sourceDataPath;
                    // If currentJsonPath is empty but it's a replay, it might be okay if pendingMistakesForNextRound is populated.
                    if (!currentJsonPath && !prog.isReplaying) {
                        console.warn("[Resume] Invalid save: no sourceDataPath and not replaying.");
                        localStorage.removeItem('gameProgress');
                        document.getElementById('resumeButton').style.display = 'none';
                        document.querySelector('.progress-actions').style.display = 'none';
                        document.querySelector('.start-buttons').style.display = 'flex';
                        return;
                    }

                    currentQuestionSet = prog.currentQuestionSetData || [];
                    isReplaying = prog.isReplaying || false;
                    pendingMistakesForNextRound = prog.pendingMistakesForNextRound || [];

                    numOfProbs = currentQuestionSet.length;

                    // Restore global x to the specific value from prog
                    window.x = Number(prog.x) ?? -1;
                    if (window.x >= numOfProbs && numOfProbs > 0) window.x = numOfProbs - 1;
                    else if (window.x >= numOfProbs && numOfProbs === 0) window.x = -1;


                    done = (Array.isArray(prog.done) && prog.done.length === numOfProbs) ? prog.done : new Array(numOfProbs).fill(false);
                    correct = Number(prog.correct) || 0;
                    wrong = Number(prog.wrong) || 0;
                    window.score = Number(prog.score) || 0;
                    correctList = Array.isArray(prog.correctList) ? prog.correctList : [];
                    wrongList = Array.isArray(prog.wrongList) ? prog.wrongList : [];
                    viewing = prog.viewingState || false;

                    updateScoreDisplay(); // Update displayed scores
                    fetchLeaderboard(); // Fetch latest leaderboard

                    document.querySelector('.start-screen').style.display = 'none';
                    document.querySelector('.flashcard-container').style.display = 'flex';
                    window.gameplayActive = true;
                    document.getElementById('next').style.display = 'block'; // Ensure next button is visible

                    if (done.every(d => d) && numOfProbs > 0) { // Resuming at the end of a round
                        console.log("[Resume] Resuming at end of a round.");
                        viewing = true; // Critical for showing answer card

                        if (window.x >= 0 && window.x < numOfProbs && currentQuestionSet[window.x]) {
                            document.getElementById("image").src = currentQuestionSet[window.x].path || "";
                            document.getElementById("image").classList.add('loaded');
                            document.querySelector('.loading-screen').style.display = 'none';
                            preloadNextImage();

                            const lastAnswerData = currentQuestionSet[window.x];
                            const saDiv = document.getElementById("showAnswer");
                            saDiv.innerHTML = `<strong style="color: #F59E0B;">上次作答題目：</strong>${lastAnswerData.answer.join(' / ')}`;
                            if (lastAnswerData.answer && lastAnswerData.answer.length > 0) {
                                addOrUpdateSpeakButton(lastAnswerData.answer[0], saDiv);
                            }
                            showExplanation(); // Uses global x, which is now restored

                            document.querySelector('.card-answer').style.display = "flex";
                        }
                        handleEndOfRound(); // Sets button text ("重玩錯誤" or hides it) and input visibility
                    } else if (numOfProbs > 0 && window.x >= 0 && window.x < numOfProbs) { // Resuming mid-round
                        console.log("[Resume] Resuming mid-round at question x:", window.x);
                        document.getElementById('next').textContent = '下一個';
                        if (viewing) { // Was viewing an answer card
                            document.getElementById("image").src = currentQuestionSet[window.x].path || "";
                            document.getElementById("image").classList.add('loaded');
                            document.querySelector('.loading-screen').style.display = 'none';
                            preloadNextImage();

                            const currentAnswerData = currentQuestionSet[window.x];
                            const saDiv = document.getElementById("showAnswer");
                            saDiv.innerHTML = `<strong style="color: #F59E0B;">答案：</strong>${currentAnswerData.answer.join(' / ')}`;
                            if (currentAnswerData.answer && currentAnswerData.answer.length > 0) {
                                addOrUpdateSpeakButton(currentAnswerData.answer[0], saDiv);
                            }
                            showExplanation(); // Uses global x

                            document.querySelector('.card-answer').style.display = "flex";
                            document.querySelector('.answer-input-container').style.visibility = 'hidden';
                            document.querySelector('.bottom-buttons').style.visibility = 'hidden';
                            document.querySelector('.your-answer-label').style.visibility = 'hidden';
                        } else { // Was about to answer a question
                            updateImage(true); // true = isResuming, use current window.x
                            document.querySelector('.card-answer').style.display = 'none';
                            document.querySelector('.answer-input-container').style.visibility = 'visible';
                            document.querySelector('.bottom-buttons').style.visibility = 'visible';
                            document.querySelector('.your-answer-label').style.visibility = 'visible';
                            document.getElementById("answer").value = "";
                            document.getElementById("answer").focus();
                            const desc = currentQuestionSet[window.x]?.description;
                            if (desc && desc.trim() !== "") document.getElementById("answer").placeholder = desc;
                            else adjustPlaceholder();
                            hideExplanation();
                        }
                    } else if (isReplaying && numOfProbs === 0) { // Resumed a replay round that successfully cleared all mistakes
                        console.log("[Resume] Resuming a successful replay round (no mistakes).");
                        showAlertModal('恭喜！所有錯誤都已訂正完畢！🎉');
                        isReplaying = false; pendingMistakesForNextRound = []; currentJsonPath = "";
                        document.getElementById('next').style.display = 'none';
                        localStorage.removeItem('gameProgress');
                        document.querySelector('.flashcard-container').style.display = 'none';
                        document.querySelector('.start-screen').style.display = 'flex';
                        window.gameplayActive = false;
                    } else {
                        console.warn("[Resume] Unhandled resume state or empty/invalid question set. prog:", prog);
                        localStorage.removeItem('gameProgress');
                        // Show start screen
                        document.querySelector('.flashcard-container').style.display = 'none';
                        document.querySelector('.start-screen').style.display = 'flex';
                        window.gameplayActive = false;
                        document.getElementById('resumeButton').style.display = 'none';
                        document.querySelector('.progress-actions').style.display = 'none';
                        document.querySelector('.start-buttons').style.display = 'flex';
                    }
                } catch (e) {
                    console.error("Error parsing saved progress or resuming:", e);
                    localStorage.removeItem('gameProgress');
                    // UI reset to start
                    document.getElementById('resumeButton').style.display = 'none';
                    document.querySelector('.progress-actions').style.display = 'none';
                    document.querySelector('.start-buttons').style.display = 'flex';
                    document.querySelector('.flashcard-container').style.display = 'none';
                    document.querySelector('.start-screen').style.display = 'flex';
                    showAlertModal("進度讀取失敗，已重設。");
                }
            } else { // No saved progress
                document.getElementById('resumeButton').style.display = 'none';
                document.querySelector('.progress-actions').style.display = 'none';
                document.querySelector('.start-buttons').style.display = 'flex';
            }


            const resumeBtn = document.getElementById('resumeButton'); // Already handled by the block above
            const restartProgress = document.getElementById('restartProgress');

            if (restartProgress) {
              restartProgress.addEventListener('click', () => {
                // ... (existing restartProgress logic, seems fine) ...
                // Ensure new state variables are also reset if necessary
                isReplaying = false;
                pendingMistakesForNextRound = [];
                currentJsonPath = "";
                allQuestions = [];
                currentQuestionSet = [];
                // ... rest of the reset ...
              });
            }
        } // End of init()

        function initializeNewGameSession(jsonPath) {
            console.log(`[initializeNewGameSession] Starting new game with ${jsonPath}`);
            window.gameplayActive = true;
            const nameInputVal = document.getElementById("playerName").value.trim();
            if (!nameInputVal) {
                showAlertModal("請先輸入玩家名稱！");
                document.getElementById("playerName").focus();
                window.gameplayActive = false;
                return;
            }
            window.currentPlayer = nameInputVal;
            localStorage.setItem("parasite_player_name", nameInputVal);
            document.querySelector('.flashcard-container').style.display = 'flex';
            document.querySelector('.start-screen').style.display = 'none';
            fetchLeaderboard();

            currentJsonPath = jsonPath;
            isReplaying = false;
            pendingMistakesForNextRound = [];
            allQuestions = []; // Clear previous full deck

            correct = 0; wrong = 0;
            correctList = []; wrongList = [];
            // window.score is persistent across full games unless explicitly reset by user/game design.
            // For a new game type, it's fine if window.score continues.
            // If a full reset of window.score is desired when starting any new game, add: window.score = 0;

            document.getElementById("correct").innerText = correct;
            document.getElementById("wrong").innerText = wrong;
            updateScoreDisplay();

            $.getJSON(jsonPath)
                .done(function (jsonData) {
                    try {
                        allQuestions = parseMultiAns(jsonData);
                        currentQuestionSet = [...allQuestions];
                        if (currentQuestionSet.length === 0) throw new Error("No data loaded from JSON for current set.");
                        console.log("[initializeNewGameSession] Data loaded. currentQuestionSet length:", currentQuestionSet.length);
                        startNewRound();
                    } catch (error) {
                        console.error("Error processing JSON data in initializeNewGameSession:", error);
                        showAlertModal("Failed to load or process game data.");
                        window.gameplayActive = false;
                        document.querySelector('.flashcard-container').style.display = 'none';
                        document.querySelector('.start-screen').style.display = 'flex';
                    }
                })
                .fail(function (jqXHR, textStatus, errorThrown) {
                    console.error("Failed to load JSON in initializeNewGameSession:", textStatus, errorThrown);
                    showAlertModal("無法讀取遊戲資料");
                    window.gameplayActive = false;
                    document.querySelector('.flashcard-container').style.display = 'none';
                    document.querySelector('.start-screen').style.display = 'flex';
                });
        }

        function startReplayMistakesSession() {
            console.log("[startReplayMistakesSession] Starting replay of mistakes.");
            window.gameplayActive = true;
            document.querySelector('.flashcard-container').style.display = 'flex';
            document.querySelector('.start-screen').style.display = 'none';

            isReplaying = true;
            currentQuestionSet = [...pendingMistakesForNextRound];

            correct = 0; wrong = 0;
            correctList = []; wrongList = [];
            document.getElementById("correct").innerText = correct;
            document.getElementById("wrong").innerText = wrong;
            updateScoreDisplay();

            console.log("[startReplayMistakesSession] currentQuestionSet for replay:", currentQuestionSet.length, "items");
            startNewRound();
        }

        function startNewRound() {
            console.log("[startNewRound] Setting up new round. isReplaying:", isReplaying, "currentQuestionSet size:", currentQuestionSet.length);
            numOfProbs = currentQuestionSet.length;

            if (numOfProbs === 0) {
                console.log("[startNewRound] No questions in currentQuestionSet.");
                if (isReplaying) {
                    showAlertModal('恭喜！所有錯誤都已訂正完畢！🎉');
                    isReplaying = false;
                    pendingMistakesForNextRound = [];
                    currentJsonPath = ""; // Game sequence over
                    document.getElementById('next').style.display = 'none';
                    localStorage.removeItem('gameProgress');
                } else {
                    showAlertModal("沒有題目可以玩了！請選擇其他題庫。");
                    document.getElementById('next').style.display = 'none';
                }
                document.querySelector('.flashcard-container').style.display = 'none';
                document.querySelector('.start-screen').style.display = 'flex';
                window.gameplayActive = false;
                return;
            }

            done = new Array(numOfProbs).fill(false);
            x = -1;

            document.getElementById('next').textContent = '下一個';
            document.querySelector('.card-answer').style.display = 'none';
            document.querySelector('.answer-input-container').style.visibility = 'visible';
            document.querySelector('.bottom-buttons').style.visibility = 'visible';
            document.querySelector('.your-answer-label').style.visibility = 'visible';
            document.getElementById('next').style.display = 'block';

            advanceToNextQuestionFlow();
        }

        document.getElementById("next").addEventListener("click", function() {
            const buttonText = this.textContent;
            console.log(`[Next Button Click] Text: "${buttonText}"`);
            if (buttonText === '重玩錯誤') {
                startReplayMistakesSession();
            } else {
                advanceToNextQuestionFlow();
            }
        });

        function advanceToNextQuestionFlow() {
            console.log("[advanceToNextQuestionFlow] Advancing. Current 'done' status for round:", done.filter(d => d).length, "/", numOfProbs);
            if (done.every(d => d) && numOfProbs > 0) {
                console.log("[advanceToNextQuestionFlow] All questions in current round are done.");
                handleEndOfRound();
                return;
            }
            if (numOfProbs === 0) {
                console.warn("[advanceToNextQuestionFlow] numOfProbs is 0. Aborting.");
                handleEndOfRound();
                return;
            }

            console.log("[advanceToNextQuestionFlow] Proceeding to display next question.");
            const showAnsDiv = document.getElementById("showAnswer");
            const existingSpeakButton = showAnsDiv.querySelector('.speak-answer-icon-button');
            if (existingSpeakButton) existingSpeakButton.remove();

            document.querySelector('.card-answer').style.display = 'none';
            document.querySelector('.answer-input-container').style.visibility = 'visible';
            document.querySelector('.bottom-buttons').style.visibility = 'visible';
            document.querySelector('.your-answer-label').style.visibility = 'visible';

            viewing = false;
            resetTime();
            // countdown();

            updateImage(); // Picks new x from currentQuestionSet
            if (x === -1) { // pickNewImage failed to find an available question (should not happen if done.every is false)
                console.error("[advanceToNextQuestionFlow] updateImage resulted in x = -1. This indicates an issue.");
                handleEndOfRound(); // Treat as end of round to prevent infinite loop or error
                return;
            }


            document.getElementById("answer").value = "";
            document.getElementById("answer").focus();

            const answerInput = document.getElementById("answer");
            const currentItem = currentQuestionSet[x];
            if (!currentItem) {
                console.error("[advanceToNextQuestionFlow] currentItem is undefined. x:", x, "currentQuestionSet length:", currentQuestionSet.length);
                showAlertModal("錯誤：無法載入下一題。");
                handleEndOfRound();
                return;
            }
            const desc = currentItem.description;
            if (desc && desc.trim() !== "") {
                answerInput.placeholder = desc;
            } else {
                adjustPlaceholder();
            }
            document.getElementById("showAnswer").innerHTML = "";
            hideExplanation();

            saveStateToLocalStorage();
        }

        function handleEndOfRound() {
            console.log("[handleEndOfRound] Round ended. Wrong answers in this round:", wrongList.length, "Is replaying:", isReplaying);
            const nextButton = document.getElementById('next');
            viewing = true; // Important for UI state if user quits now

            if (wrongList.length > 0) {
                pendingMistakesForNextRound = [...wrongList];
                nextButton.textContent = '重玩錯誤';
                nextButton.style.display = 'block';

                document.querySelector('.card-answer').style.display = 'flex'; // Ensure answer card is visible
                document.querySelector('.answer-input-container').style.visibility = 'hidden';
                document.querySelector('.bottom-buttons').style.visibility = 'hidden';
                document.querySelector('.your-answer-label').style.visibility = 'hidden';

                showAlertModal(`本回合結束！您有 ${wrongList.length} 題錯誤。點擊「重玩錯誤」再次挑戰這些題目。`);
            } else { // No mistakes in this round
                if (isReplaying) {
                    showAlertModal('恭喜！所有錯誤都已訂正完畢！🎉');
                    isReplaying = false;
                    pendingMistakesForNextRound = [];
                    currentJsonPath = "";
                } else {
                    showAlertModal(`恭喜你完成！最終分數：${score} 🎉`);
                    currentJsonPath = "";
                }
                nextButton.style.display = 'none';
                localStorage.removeItem('gameProgress'); // Fully completed this sequence
                window.gameplayActive = false;
                // Optional: Go to start screen
                // document.querySelector('.flashcard-container').style.display = 'none';
                // document.querySelector('.start-screen').style.display = 'flex';
            }
            saveStateToLocalStorage(); // Save the end-of-round state
        }

        function saveStateToLocalStorage() {
            if (!currentJsonPath && !(isReplaying && pendingMistakesForNextRound.length >= 0) ) {
                 // If no active game type and not in a pending replay state, clear progress.
                 // Allow saving if isReplaying is true even if pendingMistakes is 0 (means successful replay round about to end).
                localStorage.removeItem('gameProgress');
                console.log("[saveStateToLocalStorage] No active game or replay, progress cleared.");
                return;
            }

            console.log("[saveStateToLocalStorage] Saving state. currentJsonPath:", currentJsonPath, "x:", x, "isReplaying:", isReplaying, "viewing:", viewing);
            const stateToSave = {
                sourceDataPath: currentJsonPath,
                currentQuestionSetData: currentQuestionSet,
                x: x,
                done: done,
                correct: correct,
                wrong: wrong,
                score: window.score,
                correctList: correctList,
                wrongList: wrongList,
                isReplaying: isReplaying,
                pendingMistakesForNextRound: pendingMistakesForNextRound,
                viewingState: viewing
            };
            localStorage.setItem('gameProgress', JSON.stringify(stateToSave));
            console.log("[saveStateToLocalStorage] State saved.");
        }


        function sendToGoogleDocs(content) {
            // ... (existing logic, seems fine) ...
        }

        function parseMultiAns(dataToParse) { // Renamed param to avoid conflict
            if (!dataToParse) return [];
            Object.values(dataToParse).forEach(item => {
                if (item && typeof item.answer === 'string') {
                    item.answer = item.answer.split(" / ").map(s => s.trim()).filter(s => s);
                } else if (!item || typeof item.answer === 'undefined') {
                    item.answer = []; // Ensure answer is always an array
                }
            });
            return dataToParse;
        }
        function enterKeyEvent(event) {
            if (isComposing) return;
            if (event.key === 'Enter') {
                const explanationInput = document.getElementById('explanation-input');
                if (explanationInput && document.activeElement === explanationInput && explanationInput.offsetParent !== null) {
                    event.preventDefault();
                    submitContribution();
                } else if (!viewing && document.getElementById("answer").value.trim() !== "" && window.gameplayActive) {
                    submitUserAnswer();
                } else if (viewing && document.querySelector('.card-answer').style.display === 'flex' && window.gameplayActive) {
                    // This should trigger the "next" button's logic
                    document.getElementById("next").click();
                }
            }
        }
        // startGame() is effectively replaced by initializeNewGameSession/startNewRound/advanceToNextQuestionFlow
        // function startGame() { /* ... old logic ... */ }

        function checkAns(input, ansArr) {
            if (!Array.isArray(ansArr)) return false;
            const normalizedInput = input.trim().toLowerCase();
            return ansArr.some(ans => ans.trim().toLowerCase() === normalizedInput);
        }
        function submitUserAnswer() {
            if (isComposing) return;
            var userAnswerRaw = document.getElementById("answer").value;
            var lowerUserAnswer = userAnswerRaw.trim().toLowerCase();

            if (lowerUserAnswer && lowerCaseSwearWords.some(swearWord => lowerUserAnswer.includes(swearWord))) {
                window.open('https://youtu.be/HmIMmFAV4BY', '_blank');
                document.getElementById("answer").value = "";
                return;
            }

            if (viewing) return; // Already showing an answer
            clearTimeout(tm); // If using timers

            var userAnswer = userAnswerRaw;
            if (userAnswer.trim() === "") return; // No answer submitted

            viewing = true; // Now showing answer card
            document.querySelector('.answer-input-container').style.visibility = 'hidden';
            document.querySelector('.bottom-buttons').style.visibility = 'hidden';
            document.querySelector('.your-answer-label').style.visibility = 'hidden';

            var showAnsDiv = document.getElementById("showAnswer");
            var cardAnswerDiv = document.querySelector(".card-answer");
            cardAnswerDiv.style.display = "flex";

            const currentItem = currentQuestionSet[x];
            if (checkAns(userAnswer, currentItem.answer)) {
                showAnsDiv.innerHTML = `<strong style="color: #10B981;">對了欸！！🥹</strong> 答案是：${currentItem.answer.join(' / ')}`;
                if (currentItem.answer && currentItem.answer.length > 0) {
                    addOrUpdateSpeakButton(currentItem.answer[0], showAnsDiv);
                }
                showExplanation(); // Uses global x
                updateCorrect();
            } else {
                showAnsDiv.innerHTML = `<strong style="color: #EF4444;">錯了錯了😭</strong> 正確答案是：${currentItem.answer.join(' / ')}`;
                 if (currentItem.answer && currentItem.answer.length > 0) {
                    addOrUpdateSpeakButton(currentItem.answer[0], showAnsDiv);
                }
                showExplanation(); // Uses global x
                updateWrong();
            }

            // total++; // Original usage, if needed for round progress, manage with numOfProbs and done array
            // checkCompletion(); // Replaced by logic in advanceToNextQuestionFlow/handleEndOfRound
            saveStateToLocalStorage(); // Save state after an answer
        }
        function hideExplanation() {
            const expDiv = document.getElementById("showExplanation");
            expDiv.innerHTML = ""; // Clear content
            expDiv.style.display = "none"; // Hide container
            // Also ensure contribution area is hidden if it was part of it
            const contribArea = document.getElementById('contribution-area');
            if (contribArea) contribArea.style.display = 'none';
            const noExplanationMsg = document.getElementById('no-explanation-message');
            if (noExplanationMsg) noExplanationMsg.style.display = 'block'; // Reset to default state
        }
        function showAnswer() { // This is for "Don't Know" button
            if (viewing) return;
            clearTimeout(tm);

            viewing = true;
            document.querySelector('.answer-input-container').style.visibility = 'hidden';
            document.querySelector('.bottom-buttons').style.visibility = 'hidden';
            document.querySelector('.your-answer-label').style.visibility = 'hidden';

            var showAnsDiv = document.getElementById("showAnswer");
            var cardAnswerDiv = document.querySelector(".card-answer");
            cardAnswerDiv.style.display = "flex";

            const currentItem = currentQuestionSet[x];
            showAnsDiv.innerHTML = `<strong style="color: #F59E0B;">答案：</strong>${currentItem.answer.join(' / ')}`;
            if (currentItem.answer && currentItem.answer.length > 0) {
                addOrUpdateSpeakButton(currentItem.answer[0], showAnsDiv);
            }
            showExplanation(); // Uses global x
            updateUnknown();

            // total++;
            // checkCompletion();
            saveStateToLocalStorage(); // Save state after an answer
        }
        function showExplanation() {
             var expDiv = document.getElementById("showExplanation");
            expDiv.innerHTML = ''; // Clear previous
            const currentItem = currentQuestionSet[x];
            if (!currentItem) { // Should not happen if x is valid
                expDiv.style.display = "none";
                return;
            }
            const explanationText = currentItem.explanation?.trim();
            const hasExplanation = explanationText && explanationText !== "\"\"" && explanationText !== "\"\""; // Original check for empty quoted string

            if (hasExplanation) {
                const sanitizedExplanation = explanationText.replace(/<script.*?>.*?<\/script>/gi, '');
                expDiv.innerHTML = `<strong>偷偷告訴你為什麼：</strong>${sanitizedExplanation}`;
            } else {
                expDiv.innerHTML = `
                    <div id="no-explanation-message" style="position: relative; display: inline-block;">
                        <i>這題還沒有詳解⋯不過你可以</i>
                        <span class="contribute-link" onclick="showContributionInput()">貢獻一下！</span>
                        <div class="tooltip">
                            提交詳解可獲得 10分，但亂填會被清除所有分數
                            <div class="tooltip-arrow"></div>
                        </div>
                    </div>
                    <div class="contribution-area" id="contribution-area" style="display: none;">
                        <input id="explanation-input" placeholder="請輸入你的詳解⋯"></input>
                        <button id="submit-explanation-button" onclick="submitContribution()">送出</button>
                    </div>
                `;
            }
            expDiv.style.display = "block";
        }
        window.showContributionInput = function showContributionInput() {
             // ... (existing logic, seems fine) ...
        }
        function hideContributionInput() {
             // ... (existing logic, seems fine) ...
        }
        function updateScoreDisplay() {
            const scoreDisplay = document.getElementById("score-display");
            if (scoreDisplay) scoreDisplay.textContent = window.score; // Global score
            const correctEl = document.getElementById("correct");
            if (correctEl) correctEl.textContent = correct; // Round-specific
            const wrongEl = document.getElementById("wrong");
            if (wrongEl) wrongEl.textContent = wrong;     // Round-specific
        }
        async function submitContribution() {
            // ... (existing logic, seems fine, uses global x for currentQuestionSet[x]) ...
            // Ensure it uses currentQuestionSet[x]
            const currentItem = currentQuestionSet[x];
            // ... rest of the logic using currentItem ...
            if (!currentItem) {
                showAlertModal("無法獲取當前問題資料，無法送出。");
                return;
            }
            // ...
            const num = currentItem.num || '';
            const path = currentItem.path || '';
            const answer = Array.isArray(currentItem.answer) ? currentItem.answer.join(' / ') : (currentItem.answer || '');
            const description = currentItem.description || '';
            // ...
        }
        window.submitContribution = submitContribution;
        // nextProb() is replaced by advanceToNextQuestionFlow and button click handler

        function pickNewImage() {
            console.log("[pickNewImage] Called. Current 'done' array for round:", JSON.parse(JSON.stringify(done)));
            const availableIndices = [];
            for (let i = 0; i < numOfProbs; i++) { // numOfProbs is currentQuestionSet.length
                if (!done[i]) availableIndices.push(i);
            }
            console.log("[pickNewImage] Available indices in current round:", JSON.parse(JSON.stringify(availableIndices)));

            if (availableIndices.length === 0) {
                console.warn("[pickNewImage] All questions in current round shown. This should be handled by done.every() check earlier.");
                // This state means the round is over. advanceToNextQuestionFlow should catch this.
                return -1; // Indicate no new image can be picked
            }

            const randomIndex = Math.floor(Math.random() * availableIndices.length);
            const selectedIndex = availableIndices[randomIndex];
            done[selectedIndex] = true; // Mark as shown FOR THIS ROUND
            console.log(`[pickNewImage] Selected index for current round: ${selectedIndex}. Updated 'done' array:`, JSON.parse(JSON.stringify(done)));
            return selectedIndex;
        }
        function updateImage(isResuming = false) { // isResuming means use existing global x
            console.log(`[updateImage] Called. isResuming: ${isResuming}. Current global x: ${window.x}`);
            document.querySelector('.loading-screen').style.display = 'flex';
            var imageElement = document.getElementById("image");
            imageElement.classList.remove('loaded');
            imageElement.src = ""; // Clear previous image

            if (!isResuming) {
                const newX = pickNewImage(); // pickNewImage uses `done` and `numOfProbs` for currentQuestionSet
                console.log(`[updateImage] Picked new image index. Old global x: ${window.x}, New x for round: ${newX}`);
                window.x = newX; // Update global x to the new index
            }
            // If isResuming, global x is already set from localStorage

            if (window.x === -1 || !currentQuestionSet[window.x]) {
                console.error(`[updateImage] Invalid question index or data. Global x: ${window.x}, currentQuestionSet item:`, currentQuestionSet[window.x]);
                document.querySelector('.loading-screen').style.display = 'none';
                // Potentially trigger end of round or error handling if x is bad
                if (!isResuming) handleEndOfRound(); // If picking new failed, round might be over or error
                return;
            }
            console.log(`[updateImage] Updating image for index x: ${window.x}. Item:`, JSON.parse(JSON.stringify(currentQuestionSet[window.x])));

            const picref = currentQuestionSet[window.x]?.path;

            if (picref) {
                 imageElement.setAttribute('src', picref);
                 const altText = currentQuestionSet[window.x]?.answer?.[0] || `Parasite image ${window.x + 1}`;
                 imageElement.setAttribute('alt', `Image for: ${altText}`);
                 console.log(`[updateImage] Set image src to: ${picref}, alt: Image for: ${altText}`);
            } else {
                 console.warn(`[updateImage] No image path found for index ${window.x}.`);
                 imageElement.alt = "Image not available";
                 document.querySelector('.loading-screen').style.display = 'none';
            }
            console.log("[updateImage] Exiting.");
            preloadNextImage(); // Preload after current image is set
        }
        function countdown() { } // Original, seems unused
        function resetTime() { clearTimeout(tm); } // Original
        function showWrongList() { displayListInModal(wrongList, "你這回合答錯的"); } // Clarified "this round"
        function showCorrectList() { displayListInModal(correctList, "你這回合答對的"); } // Clarified "this round"
        function displayListInModal(list, title) {
            // ... (existing logic, seems fine, uses round-specific lists) ...
        }
        function adjustPlaceholder() {
            // ... (existing logic, seems fine) ...
        }
        function showAlertModal(message) {
            // ... (existing logic, seems fine) ...
        }
        window.showAlertModal = showAlertModal;

        function closeAlertModal() {
            // ... (existing logic, seems fine) ...
        }
        window.closeAlertModal = closeAlertModal;

        window.addEventListener('click', function(event) {
            // ... (existing logic for closing alert modal, seems fine) ...
        });

        window.preloadNextImage = function preloadNextImage() {
            if (!currentQuestionSet || currentQuestionSet.length === 0 || numOfProbs === 0) return;

            // Find next available index in 'done' that is false
            let nextAvailableX = -1;
            for (let i = 0; i < numOfProbs; i++) {
                // Cycle through from current x + 1
                let potentialNext = (window.x + 1 + i) % numOfProbs;
                if (!done[potentialNext]) {
                    nextAvailableX = potentialNext;
                    break;
                }
            }

            if (nextAvailableX !== -1 && currentQuestionSet[nextAvailableX]) {
                const nextPath = currentQuestionSet[nextAvailableX].path;
                if (nextPath) {
                    const img = new Image();
                    img.src = nextPath;
                    console.log("[preloadNextImage] Preloading:", nextPath);
                }
            } else {
                console.log("[preloadNextImage] No next image to preload (round might be ending).");
            }
        }
    </script>
</body>
</html>
